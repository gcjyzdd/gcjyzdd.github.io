---
layout: post
date:   2018-03-27 17:25
categories: DiL
---

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

## Intro

## Goals

## Camera Clibration

<iframe src ='{{site.baseurl}}/assets/tass/camera-calibration.pdf' width="100%" height="500em"></iframe>


## Set the DiL system up

* Drive PX2
* Driver simulator
* Host PC with PreScan

## Calibrate PBCamera

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/proj_formula.png' /></div>

Set PBCamera properties according to the camera specs(see next section).

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-03-27 19-36-12.png' /></div>

Set chessboard in PreScan. Place the chessboard on the road.




## Calibrate camera of Drive PX2

Check [Camera specs](http://developer.download.nvidia.com/driveworks/secure/docs/Sekonix_AR0231_2MP_SF3323_60FOV_Automotive_GMSL_Camera_Datasheet_v1.0.pdf?_s2hiuyRk79zRE9nO_6lU8CCdlfUrzsKNXFwuexx77WARknUAf7YLqDaBcSZPTXUXrkggUyfNclQ2ABM0nV0ylKEMDnRCfYOknqBP48yo3tICz7f1bol6IlnAJmwj2Tf9xyBS93Q1qcVK0we5h0RG1mnn74konS0anySTI3FD2wchmfxUCM33YJNWDYrRjQJ_pGTSIfclJBUtm9VEUY3)

### Calibrate camera using tools from Nvidia

The tool is located in `/usr/local/driveworks/tools/calibration-qt`. 

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-04-09 09-58-44.png' /></div>


1. Select platform and sensor type. 
2. Fill name and params according to the *params format*. 
3. Append sensor/ Update sensor.
4. Then fill width and height of patterns. 
5. Select image folder. 
6. And click on calibrate camera.
7. You will get camera intrinsic matrix and distortion coefficients

The next step is extrinsic calibration. However, it only applies to wide angle camera ar0231. To deal with extrinsic calibration, we need to investigate the camera calibration tool that Nvidia adopts, [ocam-calib](https://sites.google.com/site/scarabotix/ocamcalib-toolbox).

### Calibration with ocam-calib

Follow the steps of the ocam-calib website to calibrate the camera. Here are a few items shoud be noticed:

1. The calibration images should be located at the root folder of ocam-calib. Otherwise, the tool cannot detect images.
2. The calibration tool does not support PNG format images. Convert PNG images to JPG format.
3. When inputting width and height of patterns, remember to subtract number of inner corners by 1 because the tool counts from 0. For example, if the pattern is 8x6, input 7x5.
4. The tool needs optimization tool box. The cool cannot work without a license of optimization toolbox.



### Cross Compilation

Check variables for CMake
```sh
ccmake ..
```

Set correct SDK path:

```sh
export VIBRANTE_PDK=/home/dev2/drivePX2/VibranteSDK/vibrante-t186ref-linux
```

Compile the code:

```sh
cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchain-V4L.cmake \
-DVIBRANTE_PDK:STRING=/home/dev1/drivePX2/VibranteSDK/vibrante-t186ref-linux \
--DCMAKE_INSTALL_PREFIX:PATH=~/Documents/projects/DiL_LC/build/install \
../
```

or 

```sh
cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchain-V4L.cmake  \
--DCMAKE_INSTALL_PREFIX:PATH=~/Documents/projects/DiL_LC/build/install \
../
```

### Plot Cross on Camera Image

Properties of image used in Driveworks:

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-03-28 16-27-42.png'/></div>

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-03-28 16-34-47.png'/></div>

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-03-28 16-35-46.png'/></div>

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/Screenshot from 2018-03-28 16-36-42.png'/></div>




### Set Camera Position

Use the calibration script of TA. Edit the default window size to [1920, 1208].

Select the correct window and tune the scale untill the camera view covers the figure, as shown bellow:

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/calibPX2.png'/></div>

Move and rotate the camera mount to make the camera view symmetric(if possible). For this specific setup shown below, it's not possible to rotate the camera mount.

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/IMG_20180328_115542_1.jpg'/></div>


### Save the camera stream as a video

### Extract images from the video

### Calibrate the camera


## Undistort PX2 camera


## Warp PX2 camera to PBCamera


## Transform pixels to world coordinate system


## Polyfitting of lane lines


## Implement MPC

<iframe src ='{{site.baseurl}}/assets/tass/motion_model_mpc.pdf' width="100%" height="800em"></iframe>

### Implement MPC on Ubuntu PC

* Accleration [-10, 3.75]
* steer [-25, 25]
* N = 25
* dt = 0.01
* [repo](https://gitlab.com/pnwork/mpc/tree/develop)

## Simple Test of MPC with PreScan

To test how MPC works with lane control, first build a simple PreScan scenario and get the desired trajectory. Fit the trajectory using 2nd order polynomials and send the coeeficients to the MPC server using udp or tcp. The MPC server sends the control input (steer angle and throtle) back to PreScan.

### PreScan Scenario

Actor Audi_A8_Sedan:

* Lane marker sensor with four scans at [0, 5, 10, 15] m
* Simple dynamic 2D
* Pathfollower with Preview
* Constant Speed 10m/s
* Standard Camera for visualization

TODO: archive the scenario when done

### Receive Data from Simulink

```cpp
/*
    Simple udp server
*/
#include<stdio.h> //printf
#include<string.h> //memset
#include<stdlib.h> //exit(0);
#include <unistd.h>  
#include<arpa/inet.h>
#include<sys/socket.h>
 
#define BUFLEN 512  //Max length of buffer
#define PORT 25000   //The port on which to listen for incoming data

void die(char *s)
{
    perror(s);
    exit(1);
}
 
int main(void)
{
    struct sockaddr_in si_me, si_other;
     
    int s, i, slen = sizeof(si_other) , recv_len;
    char buf[BUFLEN];
     
    //create a UDP socket
    if ((s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
    {
        die("socket");
    }
     
    // zero out the structure
    memset((char *) &si_me, 0, sizeof(si_me));
     
    si_me.sin_family = AF_INET;
    si_me.sin_port = htons(PORT);
    si_me.sin_addr.s_addr = htonl(INADDR_ANY);
     
    //bind socket to port
    if( bind(s , (struWaiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
Waiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
Waiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
ct sockaddr*)&si_me, sizeof(si_me) ) == -1)
    {
        die("bind");
    }
     
    //keep listening for data
    while(1)
    {
        printf("Waiting for data...");
        fflush(stdout);
         
        //try to receive some data, this is a blocking call
        if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, (socklen_t*)&slen)) == -1)
        {
            die("recvfrom()");
        }
         
        //print details of the client/peer and the data received
        printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
		float f4[4];
		memcpy(f4, (unsigned char*)buf, sizeof(float)*4);
		printf("Data: %2.3f\t%2.3f\t%2.3f\t%2.3f\n" , f4[0], f4[1], f4[2], f4[3]);
        //printf("Data: %s\n" , buf);
         
        //now reply the client with the same data
        if (sendto(s, buf, recv_len, 0, (struct sockaddr*) &si_other, slen) == -1)
        {
            die("sendto()");
        }
    }
 
    close(s);
    return 0;
}
```

Result:

```
Waiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
Waiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
Waiting for data...Received packet from 10.87.4.49:62841
Data: 1.500	2.500	3.500	4.500
...
```


### Matlab Model

<div style="text-align:center"><img src ='{{site.baseurl}}/assets/tass/mpc_model.png'/></div>

* Extract lane marker positions
* Polyfit lane marker positions using 2nd order polynomials
* Send polynomial coefficients and host vehicle velocity using UDP
* Receive steer angle and acceleration using UDP
* Convert accleration to throtle and brake pressure
* Conver steer angle from radius to degree


